{"version":3,"file":"mergeStyleSets.js","sourceRoot":"../src/","sources":["mergeStyleSets.ts"],"names":[],"mappings":"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","sourcesContent":["import { concatStyleSets } from './concatStyleSets';\nimport { extractStyleParts } from './extractStyleParts';\nimport { IStyle } from './IStyle';\nimport { IStyleOptions } from './IStyleOptions';\nimport { IConcatenatedStyleSet, IProcessedStyleSet, IStyleSet } from './IStyleSet';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { applyRegistration, styleToRegistration } from './styleToClassName';\nimport { ObjectOnly } from './ObjectOnly';\nimport { isShadowConfig, ShadowConfig } from './shadowConfig';\nimport { Stylesheet } from './Stylesheet';\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet - The first style set to be merged and reigstered.\n */\nexport function mergeStyleSets<TStyleSet>(\n  styleSet: TStyleSet | false | null | undefined,\n): IProcessedStyleSet<ObjectOnly<TStyleSet>>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet1 - The first style set to be merged.\n * @param styleSet2 - The second style set to be merged.\n */\nexport function mergeStyleSets<TStyleSet1, TStyleSet2>(\n  styleSet1: TStyleSet1 | false | null | undefined,\n  styleSet2: TStyleSet2 | false | null | undefined,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2>>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet1 - The first style set to be merged.\n * @param styleSet2 - The second style set to be merged.\n * @param styleSet3 - The third style set to be merged.\n */\nexport function mergeStyleSets<TStyleSet1, TStyleSet2, TStyleSet3>(\n  styleSet1: TStyleSet1 | false | null | undefined,\n  styleSet2: TStyleSet2 | false | null | undefined,\n  styleSet3: TStyleSet3 | false | null | undefined,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3>>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSet1 - The first style set to be merged.\n * @param styleSet2 - The second style set to be merged.\n * @param styleSet3 - The third style set to be merged.\n * @param styleSet4 - The fourth style set to be merged.\n */\nexport function mergeStyleSets<TStyleSet1, TStyleSet2, TStyleSet3, TStyleSet4>(\n  styleSet1: TStyleSet1 | false | null | undefined,\n  styleSet2: TStyleSet2 | false | null | undefined,\n  styleSet3: TStyleSet3 | false | null | undefined,\n  styleSet4: TStyleSet4 | false | null | undefined,\n): IProcessedStyleSet<\n  ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3> & ObjectOnly<TStyleSet4>\n>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n */\nexport function mergeStyleSets(\n  ...styleSets: Array<IStyleSet | undefined | false | null | ShadowConfig>\n): IProcessedStyleSet<any>;\n\nexport function mergeStyleSets(\n  shadowConfig: ShadowConfig,\n  ...styleSets: Array<IStyleSet | undefined | false | null>\n): IProcessedStyleSet<any>;\n\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n */\nexport function mergeStyleSets(\n  ...styleSets: Array<IStyleSet | undefined | false | null | ShadowConfig>\n): IProcessedStyleSet<any> {\n  return mergeCssSets(styleSets as any, getStyleOptions());\n}\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet>(\n  styleSets: [TStyleSet | false | null | undefined],\n  options?: IStyleOptions,\n): IProcessedStyleSet<ObjectOnly<TStyleSet>>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet1, TStyleSet2>(\n  styleSets: [TStyleSet1 | false | null | undefined | ShadowConfig, TStyleSet2 | false | null | undefined],\n  options?: IStyleOptions,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2>>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet1, TStyleSet2, TStyleSet3>(\n  styleSets: [\n    TStyleSet1 | false | null | undefined | ShadowConfig,\n    TStyleSet2 | false | null | undefined,\n    TStyleSet3 | false | null | undefined,\n  ],\n  options?: IStyleOptions,\n): IProcessedStyleSet<ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3>>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet1, TStyleSet2, TStyleSet3, TStyleSet4>(\n  styleSets: [\n    TStyleSet1 | false | null | undefined | ShadowConfig,\n    TStyleSet2 | false | null | undefined,\n    TStyleSet3 | false | null | undefined,\n    TStyleSet4 | false | null | undefined,\n  ],\n  options?: IStyleOptions,\n): IProcessedStyleSet<\n  ObjectOnly<TStyleSet1> & ObjectOnly<TStyleSet2> & ObjectOnly<TStyleSet3> & ObjectOnly<TStyleSet4>\n>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets<TStyleSet>(\n  styleSet: [TStyleSet | false | null | undefined],\n  options?: IStyleOptions,\n): IProcessedStyleSet<ObjectOnly<TStyleSet>>;\n\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets(\n  styleSets: Array<IStyleSet | undefined | false | null | ShadowConfig>,\n  options?: IStyleOptions,\n): IProcessedStyleSet<any> {\n  const classNameSet: IProcessedStyleSet<any> = { subComponentStyles: {} };\n\n  let shadowConfig: ShadowConfig | undefined = undefined;\n  let styleSet;\n  if (isShadowConfig(styleSets[0])) {\n    shadowConfig = styleSets[0] as ShadowConfig;\n    styleSet = styleSets[1];\n  } else {\n    styleSet = styleSets[0];\n  }\n\n  shadowConfig ??= options?.shadowConfig;\n\n  const opts = { ...options, shadowConfig };\n\n  if (!styleSet && styleSets.length <= 1) {\n    return { subComponentStyles: {} } as any;\n  }\n\n  const sheet = Stylesheet.getInstance(shadowConfig);\n  opts.stylesheet = sheet;\n  const concatenatedStyleSet = concatStyleSets(...styleSets);\n\n  const registrations = [];\n\n  for (const styleSetArea in concatenatedStyleSet) {\n    if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {\n      if (styleSetArea === 'subComponentStyles') {\n        classNameSet.subComponentStyles = (concatenatedStyleSet as IConcatenatedStyleSet<any>).subComponentStyles || {};\n        continue;\n      } else if (styleSetArea === '__shadowConfig__') {\n        continue;\n      }\n\n      const styles: IStyle = (concatenatedStyleSet as any)[styleSetArea];\n\n      const { classes, objects } = extractStyleParts(sheet, styles);\n\n      if (objects?.length) {\n        const registration = styleToRegistration(opts || {}, { displayName: styleSetArea }, objects);\n\n        if (registration) {\n          registrations.push(registration);\n          // FIXME: classNameSet invalid types - exposed in TS 4.5 - cast needed\n          (classNameSet as Record<string, any>)[styleSetArea] = classes.concat([registration.className]).join(' ');\n        }\n      } else {\n        // FIXME: classNameSet invalid types - exposed in TS 4.5 - cast needed\n        (classNameSet as Record<string, any>)[styleSetArea] = classes.join(' ');\n      }\n    }\n  }\n\n  for (const registration of registrations) {\n    if (registration) {\n      applyRegistration(registration, options?.specificityMultiplier, shadowConfig);\n    }\n  }\n\n  return classNameSet as any;\n}\n"]}